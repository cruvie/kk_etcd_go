package utils

import (
	"fmt"
	"log/slog"
	"path/filepath"

	"gitee.com/cruvie/kk_go_kit/kk_file"
	"gitee.com/cruvie/kk_go_kit/kk_stage"
	"google.golang.org/grpc"
)

type GenerateImplInput struct {
	ServerName      string
	Methods         []grpc.MethodDesc
	ApiDefPkgPath   string
	HandlersPkgPath string
}

func GenerateImpl(input GenerateImplInput) {
	content := fmt.Sprintf(`// Code generated by kk_etcd_go. DO NOT EDIT.

package api_impl

import (
	"context"

	"gitee.com/cruvie/kk_go_kit/kk_grpc"
	"github.com/cruvie/kk_etcd_go/internal/utils/internal_client"
	"%s"
)`, input.ApiDefPkgPath)

	content += fmt.Sprintf(`
type CServer struct {
	api_def.Unimplemented%sServer
	ins server
}

`, input.ServerName)

	for _, method := range input.Methods {
		content += fmt.Sprintf(`
func (x *CServer) %s(ctx context.Context, input *api_def.%s_Input) (*api_def.%s_Output, error) {
	ctx = kk_grpc.SetGrpcStage(ctx, internal_client.GlobalStage)
	return x.ins.%s(ctx, input)
}
`, method.MethodName, method.MethodName, method.MethodName,
			method.MethodName,
		)
	}

	writeFile("./api_impl", "", "unary_sdk.go", content, true)
}

func writeFile(targetPath, pkg, filename string, content string, overwrite bool) {
	filename = filepath.Join(targetPath, pkg, filename)
	if overwrite {
		err := kk_file.OverwriteOrCreateFile(filename, []byte(content))
		if err != nil {
			slog.Error("gen filename", kk_stage.NewLog(nil).Error(err).Args()...)
			return
		}
		return
	}
	err := kk_file.AppendOrCreateFile(filename, []byte(content))
	if err != nil {
		slog.Error("gen api_gen.go error", kk_stage.NewLog(nil).Error(err).Args()...)
	}
}
